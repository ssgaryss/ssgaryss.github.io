{
    "HomePage": {
        "Main": {
            "name": "Huidi Qiu",
            "greeting": "Hi there ðŸ‘‹ This is Gary's personal website"
        },
        "Navigation": {
            "Expertise": "Expertise",
            "History": "History",
            "Projects": "Projects",
            "Contact": "Contact"
        },
        "Expertise": {
            "Title": "Expertise",
            "Part1":{
                "title": "Game Client Development",
                "content": [
                    "I specialize in <1><2>game client development</2></1> with hands-on experience from my internship at <1><2>Tencent Lightspeed Studio</2></1>.",
                    "I am skilled in using <1><2>RenderDoc</2></1> for frame capturing and reverse-engineering complex rendering workflows. During my internship, I conducted in-depth analysis of the rendering techniques used in several recent games, including <1><2>Call of Duty: Black Ops VI</2></1> and <1><2>Infinity Nikki</2></1>.",
                    "With a strong foundation in <1><2>OpenGL</2></1> and a portfolio of related projects, I also have a working knowledge of <1><2>Vulkan</2></1>.",
                    "Additionally, I am familiar with <1><2>Unreal Engine</2></1> and have experience developing custom plugins to extend its functionality."
                ]
            },
            "Part2": {
                "title": "Programming Languages",
                "content": [
                    "I am highly familiar with <1><2>C++</2></1>, having completed <1><2>Advanced C++20 Programming</2></1> and developed numerous related projects such as a mini-engine.",
                    "I specialize in profiling programs and resolving performance bottlenecks efficiently, while maintaining strict and consistent coding standards.",
                    "In addition, I have extensive experience with <1><2>Python</2></1>, which has been an essential tool throughout my graduate research.",
                    "Beyond typical scripting, I have developed various plugins using Python, including those for <1><2>ZBrush</2></1>, <1><2>3ds Max</2></1>, <1><2>Blender</2></1>, and <1><2>RenderDoc</2></1>."
                ]
            },
            "Part3": {
                "title": "Research",
                "content": [
                    "My research focuses on real-time relighting algorithms based on <1><2>2D Gaussian Splatting</2></1>.",
                    "I have a solid background in <1><2>deep learning</2></1> and am familiar with <1><2>Python</2></1> and <1><2>PyTorch</2></1>.",
                    "I am skilled at implementing academic papers and rapidly understanding their key contributions."
                ]
            },
            "KeyWords": "Key words"
        },
        "History": {
            "Title": "History",
            "Time1": {
                "title": "Undergraduate Student",
                "subtitle": "Sichuan University",
                "content": "Major in Computer Science and Technology"
            },
            "Time2": {
                "title": "Graduate Researcher",
                "subtitle": "Sichuan University",
                "content": "Computer Graphics, Rendering Algorithms, Gaussian Splatting"
            },
            "Time3": {
                "title": "Game Client Development Intern",
                "subtitle": "Tencent Lightspeed Studios",
                "content": "Unreal Engine, RenderDoc, DCC Plugin Development, Rendering Technique Analysis"
            }
        },
        "Projects": {
            "Title": "Projects",
            "project-pika-engine": {
                "title": "Pika Engine",
                "description": "Pika Engine is a self-developed mini-engine designed to apply and realize the knowledge Iâ€™ve acquired through hands-on implementation."
            },
            "project-cod-analysis": {
                "title": "CoD: BO6 Analysis",
                "description": "Conducted an in-depth analysis of the rendering techniques used in the 2024 release of Call of Duty: Black Ops VI during an internship at Tencent."
            },
            "project-nikki-analysis": {
                "title": "Infinity Nikki Analysis",
                "description": "Conducted an in-depth analysis of the rendering techniques used in the 2024 release of Infinity Nikki during an internship at Tencent."
            },
            "project-rdc-parser": {
                "title": "RDC-Parser",
                "description": "RDC-Parser is a command-line tool that directly parses .rdc files, serializes their information into JSON format, and extracts associated mesh, texture, and shader data."
            },
            "project-pubg-upgrader": {
                "title": "PUBGConfigUpgrader",
                "description": "PUBGConfigUpgrader is a UE Commandlet plugin designed to automate the conversion of configuration files for the Game for Peace (PUBG Mobile China) project during its migration from UE4 to UE5.4."
            },
            "project-model-gray": {
                "title": "ModelGray",
                "description": "ModelGray is an AI-based heightmap generation plugin that I helped develop for Tencentâ€™s art team. It enables convenient one-click creation of heightmaps for subsequent relief sculpting and more, and I supported versions for both ZBrush and Blender."
            },
            "project-raytracing": {
                "title": "Ray-Tracing",
			    "description": "A ray-tracing practice project. Currently implemented with CPU multithreading; the goal is to migrate to Vulkan for GPU acceleration."
            }
        },
        "Contact": {
            "Title": "Contact Me",
            "Name": {
                "label": "Your Name",
                "placeholder": "What's your name?",
                "helperText": "Please enter your name"
            },
            "Email": {
                "label": "Email / Phone",
                "placeholder": "How can I reach you?",
                "helperText": "Please enter your email or phone number"
            },
            "Message": {
                "label": "Message",
                "placeholder": "Send me any inquiries or questions",
                "helperText": "Please enter the message"
            },
            "Send": "Send"
        }
    },

    "PikaEnginePage": {
        "Title": "Pika Engine",
        "Contents": {
            "title": "Contents",
            "items": {
                "Abstract": "Abstract",
                "ECS": "Entity Component System",
                "Lighting&Shadow": "Lighting & Shadow",
                "Material": "Material",
                "Render": "Render",
                "Physics": "Physics",
                "Serialization": "Serialization",
                "Conclusion": "Conclusion"
            }
        },
        "Abstract": {
            "title": "Abstract",
            "content1": [
               "Pika Engine is a self-developed mini-engine designed to apply and realize the knowledge Iâ€™ve acquired through hands-on implementation. Development has been on hold since I started my internship at <1>Tencent Lightspeed Studios</1>, but I plan to revisit and upgrade the engine when time permits in the future.",
               "The current Pika Engine supports both 2D and 3D scenes. In 2D scenes, it uses Quads as primitives and supports <1>Batch Rendering</1> to render the entire scene with a minimal number of draw calls. It also supports <1>2D physics simulation</1>."
            ],
            "content2": [
               "For 3D scenes, it currently supports <1>Skybox</1>, <1>Lighting</1>, and <1>Shadows</1>, and allows importing Mesh data in formats such as OBJ and FBX. The current material system is relatively simple and uses predefined <1>Blinn-Phong</1> materials. Support for <1>physically based rendering (PBR)</1> materials will be added in future versions."
            ]
        },
        "ECS": {
            "title": "Entity Component System",
            "content1": [
                "The <1>Entity Component System (ECS)</1> is a powerful architectural pattern widely adopted in modern game engines, including <1>Unreal Engine (UE)</1> and <1>Unity</1>, due to its flexibility, scalability, and performance benefits.",
                "Pika Engine utilizes the third-party library <3>entt</3> to implement its own ECS (Entity Component System). The separation of data and logic allows Pika to efficiently manage entities and their associated components, such as <1>UUID</1>, <1>Material</1>, <1>Mesh</1>, and others."
            ],
            "content2": [
                "As shown in the figure above, you can easily configure component properties, add or remove components, and perform other operations through the UI."
            ]
        },
        "Lighting&Shadow": {
            "title": "Lighting & Shadow",
            "content1": [
                "The Pika engine currently supports point lights, spotlights, and directional lights, each with integrated shadow mapping. Additional lighting types, such as area lights and emissive surfaces, are planned for future updates.",
                "To reduce common shadow mapping artifactsâ€”particularly <1>moirÃ© patterns</1> and <1>surface acne</1>â€”the engine leverages <1>reverse-Z</1> buffering alongside enhanced depth precision techniques to improve visual fidelity. <1>Depth bias</1> remains a particularly tricky aspect; a dynamic, slope-aware biasing strategy is planned for future implementation to adapt to varying light directions and surface normals, which is expected to effectively mitigate such artifacts."
            ],
            "content2": [
                "More advanced shadowing techniques such as <1>Cascaded Shadow Maps (CSM)</1>, <1>Percentage Closer Filtering (PCF)</1>, and <1>Percentage Closer Soft Shadows (PCSS)</1> have not yet been implemented, but are planned for future integration as the engine evolves."
            ]
        },
        "Material": {
            "title": "Material",
            "content": [
                "In terms of material support, the Pika engine currently offers a configurable <1>Blinn-Phong</1> shading model. Future updates will introduce support for physically based rendering (PBR) materials, as well as comprehensive import and export functionality for mainstream 3D model formats along with their associated material data. Widely used embedded-material formats such as <1>FBX</1>, <1>glb</1>, and <1>glTF</1> will be supported to ensure seamless integration with popular modeling tools and asset pipelines."
            ]
        },
        "Render": {
            "title": "Render",
            "content": [
                "Pika's rendering interface is designed using the Factory design pattern, with a clear separation between the rendering abstraction layer and the underlying graphics API. The original intent behind this design was to ensure flexibility and allow support for multiple graphics backends such as <1>OpenGL</1>, <1>DirectX 12</1>, <1>Vulkan</1>, and <1>Metal</1>.",
                "However, I later realized a key limitation with this approach: designing the API to be compatible with all backends means I have to accommodate the least capable oneâ€”namely OpenGL. Since OpenGL lacks support for modern features like command buffers and multithreaded rendering, this severely restricts the potential of my rendering system.",
                "As a result, I plan to fully drop OpenGL in the future and adopt a Vulkan-only backend. Vulkan is not only cross-platformâ€”helping reduce development overheadâ€”but also aligns better with my expertise, allowing me to implement more advanced and efficient rendering features."
            ]
        },
        "Physics": {
            "title": "Physics",
            "content": [
                "Physics systems are now an essential part of modern game engines. Currently, the Pika engine only supports physics simulation in 2D scenes. I integrated the open-source <3>Box2D</3> library to add physical collision detection and 2D rigid body components for entities in 2D scenes. For 3D scenes, NVIDIA <4>PhysX</4> is intended to be used for implementing physical simulations, with more advanced physics features planned for future development."
            ]
        },
        "Serialization": {
            "title": "Serialization",
            "content1": [
                "Serialization in Pika includes both scene serialization and deserialization. When saving the current scene state, Pika serializes key scene information into a <3>YAML</3>-based .pika file. You can import a scene by simply dragging it from the <1>Content Browser</1> into the <1>Viewport</1>, or by using the Import option from the menu bar."
            ],
            "content2": [
                "In addition, model files are also part of the serialization system. Currently, model data import and export are supported through the <3>Assimp</3> library. To load a 3D model, you can simply drag the corresponding file into the Model Component section."
            ]
        },
        "Conclusion": {
            "title": "Conclusion",
            "content": [
                "The Pika engine is a work-in-progress project. During my internship, I had limited time to keep it updated. I originally started this engine to integrate the graphics algorithms I had learned into a single impressive project and to use it as a showcase during interviews. Building the core framework consumed a significant amount of my energy, leaving little time to implement various rendering algorithms and engine features.",
                "Today, I have gained much deeper knowledge in computer graphics. Iâ€™ve analyzed the rendering techniques of cutting-edge games like <1><2><3>Call of Duty: Black Ops 6</3></2></1> and <1><2><4>Infinity Nikki</4></2></1>, and Iâ€™m currently studying the rendering concepts presented in <1><2>Real-Time Rendering, 4th Edition</2></1>. I now better understand the complexity behind top-tier engines like Unreal Engine, particularly systems such as <1>Lumen</1> and <1>Nanite</1>.",
                "With this experience, Iâ€™m more prepared than ever to advance the development of the Pika engine. In the future, Pika will focus heavily on 3D capabilities, introducing scripting support, a material system, and more rendering features includingâ€”but not limited toâ€”anti-aliasing, ambient occlusion, and global illumination. I also plan to fully abandon OpenGL in favor of Vulkan to achieve more efficient rendering. Stay tuned."
            ]
        }
    },

    "CODAnalysisPage": {
        "Title": "Call of Duty: Black Ops VI Analysis",
        "Contents": {
            "title": "Contents",
            "items": {
                "Abstract": "Abstract",
                "DOF": "Depth of Field",
                "AA": "Anti-Aliasing",
                "AO": "Ambient Occlusion",
                "Reflection": "Reflection",
                "GI": "Global Illumination",
                "Shadow": "Shadow",
                "Effects": "Effects",
                "AE": "Auto Exposure",
                "Static": "Static Geometry Rendering",
                "Animation": "Animation"
            }
        },
        "Abstract": {
            "title": "Abstract",
            "content": [
                "<1>Disclaimer</1>: This content is intended solely for educational and project showcase purposes. If any infringement is found, please <1><3>contact me</3></1> for prompt removal.",
                "This blog presents a summary of my <1>rendering analysis</1> of <1><2><4>Call of Duty: Black Ops VI</4></2></1> and a review of the associated rendering techniques. To keep the blog concise, only key highlights are covered here â€” for the full analysis, please download the detailed documentation. The full analysis document is available for download via the <1><5>Doc</5></1> button below the title."
            ]
        },
        "DOF": {
            "title": "Depth of Field",
            "content": [
                "Depth of Field"
            ]
        },
        "AA": {
            "title": "Anti-Aliasing",
            "content": [
                "Anti-Aliasing"
            ]
        },
        "AO": {
            "title": "Ambient Occlusion",
            "content": [
                "Ambient Occlusion"
            ]
        },
        "Reflection": {
            "title": "Reflection",
            "content": [
                "Reflection"
            ]
        },
        "GI": {
            "title": "Global Illumination",
            "content": [
                "Global Illumination"
            ]
        },
        "Shadow": {
            "title": "Shadow",
            "content": [
                "Shadow"
            ]
        },
        "Effects": {
            "title": "Effects",
            "content": [
                "Effects"
            ]
        },
        "AE": {
            "title": "Auto Exposure",
            "content": [
                "Auto Exposure"
            ]
        },
        "Static": {
            "title": "Static Geometry Rendering",
            "content": [
                "Static Geometry Rendering"
            ]
        },
        "Animation": {
            "title": "Animation",
            "content": [
                "Animation"
            ]
        }
    },

    "InfinityNikkiAnalysisPage": {
        "Title": "Infinity Nikki",
        "Contents": {
            "title": "Contents",
            "items": {
                "Abstract": "Abstract",
                "PPLL": "Per-Pixel Linked List OIT",
                "ShellFur": "Shell-Based Fur Rendering",
                "SSAO": "Screen Space Ambient Occlusion"
            }
        },
        "Abstract": {
            "title": "Abstract",
            "content": [
                "<1>Disclaimer</1>: This content is intended solely for educational and project showcase purposes. If any infringement is found, please <3>contact me</3> for prompt removal.",
                "This blog presents a summary of my <1>rendering analysis</1> of <1><2><4>Infinity Nikki</4></2></1> and a review of the associated rendering techniques. To keep the blog concise, only key parts are highlighted here â€” for the full analysis, please download the detailed documentation. The full analysis document is available for download via the <1><5>Doc</5></1> button below the title."
            ]
        },
        "PPLL": {
            "title": "Per-Pixel Linked List OIT",
            "content": [
                "OIT"
            ]
        },
        "ShellFur": {
            "title": "Shell-Based Fur Rendering",
            "content": [
                "Shell-Based Fur Rendering"
            ]
        },
        "SSAO": {
            "title": "Screen Space Ambient Occlusion",
            "content": [
                "Screen Space Ambient Occlusion"
            ]
        }
    },

    "RDCParserPage": {
        "Title": "RDC-Parser",
        "Contents": {
            "title": "Contents",
            "items": {
                "Abstract": "Abstract",
                "Requirements": "Requirements",
                "Challenges": "Challenges",
                "Outcomes": "Outcomes"
            }
        },
        "Abstract": {
            "title": "Abstract",
            "content": [
                "<1><2><3>RenderDoc</3></2></1> is currently one of the most effective tool for debugging the GPU. It is especially indispensable in the game industry for analyzing rendered frames.",
                "However, <1>.rdc</1> files are not human-readable, which means we have to manually analyze them in RenderDoc each time. This makes the process inefficient and time-consuming. Therefore, there is a strong need for a convenient tool to address this issue â€” and thatâ€™s the motivation behind RDC-Parser.",
                "You can download the detailed documentation by clicking the <1><4>Doc</4></1> button below the title."
            ]
        },
        "Requirements": {
            "title": "Requirements",
            "content": [
                "RDC-Parser is required to parse the <1>RenderGraph</1> information from an .rdc file and export it into a JSON file, including associated Texture, Mesh, and Shader data. In addition, it should support command-line usage without launching RenderDoc.",
                "In terms of functionality, future versions should also support visualizing the <1>.rdc</1> file as an interactive RenderGraphâ€”similar to tools like <1><2><3>ARM Frame Advisor</3></2></1>â€”so that we can intuitively understand the full rendering pipeline. The following is the RenderGraph visualization from Frame Advisor."
            ]
        },
        "Challenges": {
            "title": "Challenges",
            "content1": [
                "The main challenges arise when parsing large .rdc files. Taking a frame capture from Infinity Nikki as an example, there are two major performance bottlenecks:"
            ],
            "list": {
                "0": "The time complexity of RenderDoc's state-switching API is proportional to the size of the .rdc file.",
                "1": "Saving Textures, Meshes, and Shaders locally requires significant disk time, as each draw call contains a large amount of dataâ€”including Textures, Meshes, Shaders, and moreâ€”that needs to be parsed."
            },
            "content2": [
                "I performed extensive optimizations, such as high-concurrency I/O tasks and texture deduplication (since many textures are not render targets and do not change between draw calls). As a result, using a frame capture from my Pika Engine as an example, I reduced the processing time from over 150 seconds to under 10 seconds."
            ]
        },
        "Outcomes": {
            "title": "Outcomes",
            "content": [
                "The RDC-Parser tool constitutes only a portion of our group project and was the component I personally handled. Other modules not under my responsibility are beyond the scope of this description. Below is the test result of RDC-Parser parsing a captured frame from <1><2><3>Infinity Nikki</3></2></1>."
            ]
        }
    },

    "PUBGConfigUpgraderPage": {
        "Title": "PUBGConfigUpgrader",
        "Contents": {
            "title": "Contents",
            "items": {
                "Abstract": "Abstract",
                "Requirements": "Requirements",
                "Challenges": "Challenges",
                "Outcomes": "Outcomes"
            }
        },
        "Abstract": {
            "title": "Abstract",
            "content": [
                "PUBGConfigUpgrader is a UE Commandlet plugin tool designed to automate the migration of configuration files for the <1><2><3>Game for Peace</3></2></1> (PUBG Mobile China) project from both the public UE4 and the Tencentâ€™s internal Galaxy version of UE4 to UE5.4. It also includes customized modifications based on project team requirements to align with the features of UE5.4 and ensure compatibility with additional needs.",
                "You can download the detailed documentation by clicking the <1><4>Doc</4></1> button below the title."
            ]
        },
        "Requirements": {
            "title": "Requirements",
            "content": [
                "The project team required that UE5.4 maintain full compatibility with all UE4 functionalities, while also introducing many new configurationsâ€”such as support for some <1>HarmonyOS</1> devices (with several sensitive details omitted).",
                "The tool reads data from three `.ini` configuration files of the public UE4 version and two from the Galaxy version, then generates three corresponding `.ini` files for UE5.4. It ensures that the user's original configurationsâ€”such as custom `CVars`â€”are preserved. Numerous additional special requirements have been omitted here."
            ]
        },
        "Challenges": {
            "title": "Challenges",
            "content1": [
                "The original configuration files were highly complex, covering rendering settings for the Game for Peace lobby configurations, individual map configurations, device-specific settings, whitelists, and more.",
                "My task was to extract all relevant information while generating the corresponding UE5.4 versions, discarding outdated entries for unsupported low-end devices, introducing finer-grained performance tiers for newer, higher-end models, and carrying out a series of related tasks. On top of that, I had to ensure that all general-purpose content from the original UE4 configurations could be correctly and appropriately migrated to UE5.4."
            ]
        },
        "Outcomes": {
            "title": "Outcomes",
            "content": [
                "In the end, I successfully met all the requirements and delivered the PUBGConfigUpgrader automation tool."
            ]
        }
    },
    
    "ModelGrayPage": {
        "Title": "ModelGray",
        "Contents": {
            "title": "Contents",
            "items": {
                "Abstract": "Abstract",
                "Requirements": "Requirements",
                "Challenges": "Challenges",
                "Outcomes": "Outcomes"
            }
        },
        "Abstract": {
            "title": "Abstract",
            "content": [
                "ModelGray is a <1><2><3>ZBrush</3></2></1> and <1><2><4>Blender</4></2></1> plugin that I developed during my internship. It integrates directly into the software: when a user requests a model heightmap, the plugin sends the target image to the backend (Lightspeed Studiosâ€™ internal AI solution <1>LightAI</1>) and returns the result, greatly simplifying the workflow for artists creating relief models. The software is accessible only via the company intranet.",
                "You can download the detailed documentation by clicking the <1><5>Doc</5></1> button below the title."
            ]
        },
        "Requirements": {
            "title": "Requirements",
            "content": [
                "The project team aimed to <1>streamline the relief-model generation workflow</1> for artists. Unlike other relief pluginsâ€”which typically require jumping to a web page for AI generation (for example, the suite of plugins based on <1><2><3>OdysseyAI</3></2></1> solutions)â€”Lightspeed Studiosâ€™ internal AI solution, LightAI, also provides powerful model heightmap generation capabilities for relief creation. The team wanted to eliminate the intermediate web-based step and fetch results directly through the plugin, simplifying the sequence of target acquisition, network request, and result retrieval into a single seamless operation."
            ]
        },
        "Challenges": {
            "title": "Challenges",
            "content1": [
                "The ZBrush version of the plugin faced several challenges, primarily due to the limitations of ZBrush's native scripting language, <1><3>ZScript</3></1>, which lacks many advanced capabilities."
            ],
            "list": {
                "0": "ZScript doesn't support <1>multithreading</1>.",
                "1": "ZScript doesn't support <1>network requests</1>."
            },
            "content2": [
                "Due to these limitations, tasks such as HTTP/HTTPS requests and SSL encryption had to be handled by calling C++ code through ZScript.",
                "The Blender version, on the other hand, was much more straightforward to develop, as it allowed direct implementation using <1>Python</1>."
            ]
        },
        "Outcomes": {
            "title": "Outcomes",
            "content": [
                "ModelGray has been officially released for internal use by the companyâ€™s art team. Below are showcase images of the ZBrush and Blender plugin versions."
            ]
        }
    }

}